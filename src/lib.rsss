// // extern crate combine;
// // extern crate combine_language;
// use combine::*;
// use combine::parser::char::*;
// use combine::stream::state::State;
// use combine::parser::char::{digit, letter};
// use combine_language::{Identifier, LanguageEnv, LanguageDef};


// enum SyntaxNode{
//     Derived,
//     AccessorDeclarationSyntax,
//     AccessorListSyntax,
//     AnonymousObjectMemberDeclaratorSyntax,
//     ArgumentSyntax,
//     ArrayRankSpecifierSyntax,
//     ArrowExpressionClauseSyntax,
//     AttributeArgumentListSyntax,
//     AttributeArgumentSyntax,
//     AttributeListSyntax,
//     AttributeSyntax,
//     AttributeTargetSpecifierSyntax,
//     BaseArgumentListSyntax,
//     BaseCrefParameterListSyntax,
//     BaseListSyntax,
//     BaseParameterListSyntax,
//     BaseTypeSyntax,
//     CatchClauseSyntax,
//     CatchDeclarationSyntax,
//     CatchFilterClauseSyntax,
//     CompilationUnitSyntax,
//     ConstructorInitializerSyntax,
//     CrefParameterSyntax,
//     CrefSyntax,
//     ElseClauseSyntax,
//     EqualsValueClauseSyntax,
//     ExplicitInterfaceSpecifierSyntax,
//     ExpressionSyntax,
//     ExternAliasDirectiveSyntax,
//     FinallyClauseSyntax,
//     InterpolatedStringContentSyntax,
//     InterpolationAlignmentClauseSyntax,
//     InterpolationFormatClauseSyntax,
//     JoinIntoClauseSyntax,
//     MemberDeclarationSyntax,
//     NameColonSyntax,
//     NameEqualsSyntax,
//     OrderingSyntax,
//     ParameterSyntax,
//     PatternSyntax,
//     QueryBodySyntax,
//     QueryClauseSyntax,
//     QueryContinuationSyntax,
//     SelectOrGroupClauseSyntax,
//     StatementSyntax,
//     StructuredTriviaSyntax,
//     SwitchLabelSyntax,
//     SwitchSectionSyntax,
//     TupleElementSyntax,
//     TypeArgumentListSyntax,
//     TypeParameterConstraintClauseSyntax,
//     TypeParameterConstraintSyntax,
//     TypeParameterListSyntax,
//     TypeParameterSyntax,
//     UsingDirectiveSyntax,
//     VariableDeclarationSyntax,
//     VariableDeclaratorSyntax,
//     VariableDesignationSyntax,
//     WhenClauseSyntax,
//     XmlAttributeSyntax,
//     XmlElementEndTagSyntax,
//     XmlElementStartTagSyntax,
//     XmlNameSyntax,
//     XmlNodeSyntax,
//     XmlPrefixSyntax,
// }



// fn nommm(){

// }

// #[cfg(test)]
// mod tests2 {
//     use super::*;

//     #[test]
//     fn nommm_test() {
//         nommm();
//     }
// }


// fn ms(){


//     // Construct a parser that parses *many* (and at least *1) *letter*s
//     let word = many1(letter());

//     // Construct a parser that parses many *word*s where each word is *separated by* a (white)*space*
//     let mut parser = sep_by(word, space())
//         // Combine can collect into any type implementing `Default + Extend` so we need to assist rustc
//         // by telling it that `sep_by` should collect into a `Vec` and `many1` should collect to a `String`
//         .map(|words: Vec<String>| words);

//     // println!("HAAAAA");

//     println!("{:?}", parser.parse("Pick up that word!") );
//     println!("{:?}", parser.parse("!") );
//     println!("{:?}", parser.parse("") );

//     // one_of(digit());
//     digit().or(letter()).easy_parse(State::new("|"));
//     // println!("{:?}", parser..parse("") );
    
//     // `parse` returns `Result` where `Ok` contains a tuple of the parsers output and any remaining input.
//     // assert_eq!(result, Ok((Some("word".to_string()), "!")));
// }


// fn rs() {
//     let env = LanguageEnv::new(LanguageDef {
//         ident: Identifier {
//             start: letter(),
//             rest: alpha_num(),
//             reserved: ["if", "then", "else", "var", "in", "for", "foreach", "const", "using", "class", "public", "private", "internal", "protected", "static", "ref"]
//                 .iter().map(|x| (*x).into()).collect(),
//         },
//         op: Identifier {
//             start: satisfy(|c| "+-*/".chars().any(|x| x == c)),
//             rest: satisfy(|c| "+-*/".chars().any(|x| x == c)),
//             reserved: ["+", "-", "*", "/"].iter().map(|x| (*x).into()).collect()
//         },
//         comment_start: string("/*").map(|_| ()),
//         comment_end: string("*/").map(|_| ()),
//         comment_line: string("//").map(|_| ()),

//     });
    
//     let id = env.identifier();//An identifier parser
//     let integer = env.integer();//An integer parser
    
//     let result = (id, integer).easy_parse("this /* Skips comments */ 42");
//     assert_eq!(result, Ok(((String::from("this"), 42), "")));

//     // env.
// }

// #[cfg(test)]
// mod tests {
//     use super::*;

//     #[test]
//     fn it_works() {
//         rs();
//     }
    
//       #[test]
//     fn it_works2() {
//         ms();
//     }
// }
