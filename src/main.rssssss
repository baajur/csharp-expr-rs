extern crate nom;
use nom::{
  IResult,
  bytes::complete::{tag, take_while_m_n},
  combinator::map_res,
  sequence::tuple
};

#[derive(Debug,PartialEq)]
pub struct Color {
  pub red:   u8,
  pub green: u8,
  pub blue:  u8,
}

fn from_hex(input: &str) -> Result<u8, std::num::ParseIntError> {
  u8::from_str_radix(input, 16)
}

fn is_hex_digit(c: char) -> bool {
  c.is_digit(16)
}

fn hex_primary(input: &str) -> IResult<&str, u8> {
  map_res(
    take_while_m_n(2, 2, is_hex_digit),
    from_hex
  )(input)
}

fn hex_color(input: &str) -> IResult<&str, Color> {
  let (input, _) = tag("#")(input)?;
  let (input, (red, green, blue)) = tuple((hex_primary, hex_primary, hex_primary))(input)?;

  Ok((input, Color { red, green, blue }))
}

fn main(){}

// #[test]
// fn parse_color() {
//   assert_eq!(hex_color("#2F14DF"), Ok(("", Color {
//     red: 47,
//     green: 20,
//     blue: 223,
//   })));
// }

// use nom::{Err, error::ErrorKind};

//   fn take_while1() {
//     named!(myfunc<&str,&str>, take_while1!(is_alphabetic));
//     let a = "";
//     let b = "abcd";
//     let c = "abcd123";
//     let d = "123";

//     assert_eq!(myfunc(&a[..]), Err(Err::Incomplete(Needed::Size(1))));
//     assert_eq!(myfunc(&b[..]), Err(Err::Incomplete(Needed::Size(1))));
//     assert_eq!(myfunc(&c[..]), Ok((&"123"[..], &b[..])));
//     assert_eq!(
//       myfunc(&d[..]),
//       Err(Err::Error(error_position!(&d[..], ErrorKind::TakeWhile1)))
//     );
// }

#[test]
fn parse_color2() {
  assert_eq!(hex_color("#2F14DF"), Ok(("", Color {
    red: 47,
    green: 20,
    blue: 223,
  })));
}